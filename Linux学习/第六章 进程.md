## 1. ps

进程是运行在您机器上的程序。它们由内核管理，每个进程都有一个与之关联的 ID，称为**进程 ID (PID)**。这个 PID 是按照进程创建的顺序分配的。

现在运行 ps 命令查看正在运行的进程列表：

```Shell
ps

PID        TTY     STAT   TIME          CMD
  
41230    pts/4    Ss        00:00:00     bash
  
51224    pts/4    R+        00:00:00     ps
```
  
这会显示当前进程的快速快照：

- PID: 进程 ID
- TTY: 与进程关联的控制终端（我们稍后会详细说明）
- STAT: 进程状态码
- TIME: 总 CPU 使用时间
- CMD：可执行文件/命令的名称

如果你查看 ps 的手册页，你会发现有很多命令选项可以传递，它们会根据你想要使用的选项（BSD、GNU 或 Unix）而有所不同。在我看来，BSD 风格更受欢迎，所以我们选择这种方式。如果你好奇，这些风格之间的区别在于使用的破折号数量和标志。

```Shell
ps aux
```

**a** 显示所有正在运行的进程，包括其他用户运行的进程。**u** 显示更多关于进程的详细信息。最后，**x** 列出所有没有关联 TTY 的进程，这些程序在 TTY 字段会显示一个？，它们最常见于作为系统启动一部分启动的守护进程。

你会注意到现在看到了很多更多字段，没有必要全部记住它们，在后续的高级进程课程中，我们会再次讨论其中一些。

- 用户：有效用户（我们正在使用的访问者）
- 进程 ID：进程标识符
- %CPU：进程使用的 CPU 时间除以进程运行时间
- %MEM：进程驻留集大小与机器物理内存的比率
- VSZ：整个进程的虚拟内存使用量
- RSS：常驻集大小，任务使用的未交换的物理内存
- TTY：与进程关联的控制终端
- STAT：进程状态码
- START：进程开始时间
- 时间：总 CPU 使用时间
- 命令：可执行文件/命令名称

ps 命令的输出可能会有些混乱，目前我们最关注的字段是 PID、STAT 和 COMMAND。

另一个非常实用的命令是 **top** 命令，top 可以提供系统上正在运行进程的实时信息，而不是快照。默认情况下，每 10 秒刷新一次。top 是一个非常实用的工具，可以查看哪些进程占用了大量资源。

```Shell
top
```

## 2. 控制终端

我们讨论过 ps 输出中有一个 TTY 字段。TTY 是执行命令的终端。

终端有两种类型，普通终端设备和伪终端设备。普通终端设备是你可以输入并输出到系统的原生终端设备，这听起来像是你一直用来进入 shell 的终端应用程序，但它不是。

我们将过渡到这个操作，请按 Ctrl-Alt-F1 进入 TTY1（第一个虚拟控制台），你会发现除了终端什么都没有，没有图形等。这被认为是一个普通终端设备，你可以用 Ctrl-Alt-F7 退出这个终端。

伪终端是你一直都在使用的终端，它们通过模拟终端窗口和 shell 终端来工作，并以 PTS 表示。如果你再次查看 ps 命令，你会在 pts/目录下看到你的 shell 进程。

好的，现在回到控制终端的话题，进程通常绑定到一个控制终端。例如，如果你在 shell 窗口中运行一个程序，比如 find，然后关闭窗口，你的进程也会随之结束。

有一些进程，比如守护进程，是特殊的进程，它们基本上是保持系统运行。它们通常在系统启动时启动，并在系统关闭时终止。它们在后台运行，由于我们不想让这些特殊进程被终止，所以它们不绑定到控制终端。在 ps 命令的输出中，TTY 列出的值是 **?**，表示它没有控制终端。

## 3. 进程细节

在深入探讨进程的实际应用之前，我们必须先了解它们是什么以及它们是如何工作的。这一部分可能会让人感到困惑，因为我们正在深入探讨细节，如果你现在不想学习这部分内容，可以随时回到这一课。

正如我们之前所说，进程是系统上正在运行的程序，更精确地说，它是系统分配内存、CPU、I/O 来使程序运行的过程。进程是正在运行程序的实例，现在打开 3 个终端窗口，在两个窗口中，运行不带任何选项的 **cat** 命令（cat 进程会作为一个进程保持打开状态，因为它期望标准输入）。现在在第三个窗口中运行：**ps aux | grep cat**。你会看到有两个 cat 进程，尽管它们调用的是同一个程序。

内核负责进程，当我们运行一个程序时，内核将程序的代码加载到内存中，确定并分配资源，然后跟踪每个进程，它知道：

- 进程的状态
- 进程使用和接收的资源
- 进程的所有者
- 信号处理（稍后详细介绍）
- 基本上其他所有东西

所有进程都在试图分一杯那块甜美的资源蛋糕，而内核的工作就是确保根据进程的需求分配适量的资源。当进程结束时，它所使用的资源现在就会被释放出来供其他进程使用。

## 4. 进程创建

这一课和下一课纯粹是提供信息，让你了解系统内部的运作方式，当你对进程有更多了解后，可以随时回顾这部分内容。

当创建新进程时，现有进程基本上使用名为 fork 的系统调用（系统调用将在未来更深入地讨论）进行自我克隆。fork 系统调用会创建一个几乎完全相同的子进程，这个子进程会获得一个新的进程 ID（PID），而原始进程则成为其父进程，并拥有一个称为父进程 ID **PPID** 的标识。之后，子进程可以继续使用其父进程之前使用的同一个程序，或者更常见的是使用 execve 系统调用来启动一个新程序。这个系统调用会销毁内核为该进程设置的内存管理机制，并为新程序设置新的内存管理机制。

我们可以看到这个过程的具体运作：

```Shell
ps l
```

-l 选项会给我们一个"长格式"或更详细的运行进程视图。你会看到一个标记为 **PPID** 的列，这是父进程 ID。现在看看你的终端，你会看到一个正在运行的进程，那是你的 shell，所以在我的系统上我有一个运行 bash 的进程。现在记住当你运行 ps l 命令时，你是从运行 bash 的进程来运行的。现在你会看到 bash shell 的 **PID** 是 **PPID** 的 **ps l** 命令。

既然每个进程都必须有一个父进程，并且它们只是彼此的子进程，那么一定有一个所有进程的母亲进程对吗？你是对的，当系统启动时，内核会创建一个名为 **init** 的进程，它的 PID 为 1。init 进程除非系统关闭否则无法终止。它以 root 权限运行，并运行许多进程来保持系统运行。我们将在系统启动课程中更详细地研究 init，目前只需知道它是所有其他进程的父进程。

## 5. 进程终止

既然我们已经知道进程创建时会发生什么，那么当我们不再需要它时会发生什么呢？请注意，有时候 Linux 可能会变得有些黑暗...

进程可以通过_exit 系统调用退出，这将释放进程正在使用的资源以便重新分配。所以当进程准备终止时，它会通过一种称为终止状态的东西通知内核它为什么要终止。最常见的情况是状态为 0 表示进程成功。然而，这并不足以完全终止一个进程。父进程必须通过使用 wait 系统调用来确认子进程的终止，这个调用会检查子进程的终止状态。我知道这听起来很残忍，但 wait 调用是必要的，毕竟哪个父母不希望知道自己的孩子是怎么死的呢？

还有一种终止进程的方法，那就是使用信号，我们很快就会讨论。

**孤儿进程**

当父进程在子进程之前终止时，内核知道它将不会收到一个 wait 调用，因此它将这些进程变为"孤儿"，并将它们交给 init（记住所有进程的母亲）来照顾。init 最终会为这些孤儿进程执行 wait 系统调用，以便它们能够终止。

**僵尸进程**

当子进程终止而父进程尚未调用 wait 时会发生什么？我们仍然希望能够看到子进程是如何终止的，因此即使子进程已经完成，内核也会将子进程转变为僵尸进程。子进程使用的资源仍然会被释放给其他进程，但进程表中仍然会保留这个僵尸进程的条目。由于僵尸进程在技术上已经"死亡"，所以它们也无法被杀死，不能使用信号来杀死它们。最终如果父进程调用 wait 系统调用，僵尸进程就会消失，这被称为"回收"。如果父进程不执行 wait 调用，init 进程会收养这个僵尸进程并自动执行 wait 来移除它。拥有过多的僵尸进程可能是一件坏事，因为它们会占用进程表的空间，如果进程表满了，就会阻止其他进程运行。

## 6. Signals

信号是通知进程某事已发生的一种通知。

**我们为何要有信号**

它们是软件中断，并且有很多用途：

- 用户可以输入特殊终端字符（Ctrl-C）或（Ctrl-Z）来终止、中断或挂起进程
- 可能会出现硬件问题，内核想要通知进程
- 可能会出现软件问题，内核想要通知进程
- 它们基本上是进程之间可以通信的方式

**信号处理**

当某个事件生成信号时，该信号会被传递给一个进程，此时信号处于挂起状态，直到被传递。当进程运行时，信号将被传递。然而，进程有信号掩码，如果指定，它们可以阻止信号传递。当信号被传递时，进程可以执行多种操作：

- 忽略信号
- "捕获"信号并执行特定的处理例程
- 进程可以被终止，与正常的退出系统调用相反
- 根据信号掩码阻塞信号

**常见信号**

每个信号都由具有 SIGxxx 形式的符号名称的整数定义。一些最常见的信号包括：

- SIGHUP 或 HUP 或 1：挂断
- SIGINT 或 INT 或 2：中断
- SIGKILL 或 KILL 或 9：杀死
- SIGSEGV 或 SEGV 或 11：段错误
- SIGTERM 或 TERM 或 15：软件终止
- SIGSTOP 或 STOP：停止

信号编号可能有所不同，因此通常以其名称来指代。

有些信号是不可阻塞的，例如 SIGKILL 信号。KILL 信号会销毁进程。

## 7. kill

你可以发送终止进程的信号，这个命令恰如其名叫做 kill 命令。

```Shell
kill 12445
```

12445 是你想要终止的进程的 PID。默认情况下，它会发送 TERM 信号。SIGTERM 信号被发送给进程，请求其终止，允许其干净地释放资源并保存其状态。

你也可以使用 kill 命令指定一个信号：

```Shell
kill -9 12445
```

这将发送 SIGKILL 信号并终止进程。

**SIGHUP、SIGINT、SIGTERM、SIGKILL、SIGSTOP 之间的区别？**

这些信号听起来都相当相似，但它们确实存在差异。

- SIGHUP - 挂起，当控制终端关闭时发送给进程。例如，如果你关闭了一个包含正在运行进程的终端窗口，你会收到一个 SIGHUP 信号。基本上，你被挂起了
- SIGINT - 是一个中断信号，因此你可以使用 Ctrl-C，系统会尝试优雅地终止进程
- SIGTERM - 终止进程，但允许它先做一些清理工作
- SIGKILL - 终止进程，用火将其杀死，不做任何清理
- SIGSTOP - 停止/挂起进程

## 8. niceness

当你在电脑上同时运行多个程序，比如 Chrome、Microsoft Word 或 Photoshop 时，这些程序似乎在同时运行，但这并不完全正确。

进程会使用 CPU 一个称为时间片的小段时间。然后它们暂停几毫秒，另一个进程获得一点时间片。默认情况下，进程调度以这种循环方式进行。每个进程都会获得足够的时间片，直到它完成处理。内核处理所有这些进程的切换，并且大多数情况下做得相当好。

进程无法决定何时以及多长时间获得 CPU 时间，如果所有进程都表现正常，它们将（大致）获得相等的 CPU 时间。然而，有一种方法可以通过 nice 值影响内核的进程调度算法。nice 是一个相当奇怪的名字，但它指的是进程有一个数字来确定它们对 CPU 的优先级。高数字意味着进程很友好，对 CPU 的优先级较低；低数字或负数字意味着进程不太友好，它想尽可能多地获得 CPU 时间。

```Shell
top
```

现在可以看到一个 NI 列，那是进程的优先级。

要改变优先级，可以使用 nice 和 renice 命令：

```Shell
nice -n 5 apt upgrade
```

nice 命令用于为新进程设置优先级。renice 命令用于为现有进程设置优先级。

```Shell
renice 10 -p 3245
```

## 9. Process States

让我们再次看看 ps aux 命令：

```Shell
ps aux
```

在 STAT 列中，你会看到很多值。Linux 进程可以处于多种不同的状态。最常见的状态代码如下所述：

- R：运行或可运行，它只是在等待 CPU 处理它
- S: 可中断睡眠，等待事件完成，例如终端输入
- D: 不可中断睡眠，进程不能被信号杀死或中断，通常需要重启或修复问题才能使其消失
- Z: 僵尸，我们在上一课中讨论过，僵尸是等待其状态被收集的已终止进程
- T: 停止，一个已被挂起/停止的进程

## 10. /proc文件系统

在 Linux 中，一切皆文件，进程也不例外。进程信息存储在一个特殊的文件系统中，称为/proc 文件系统。

```Shell
ls /proc
```

你应该能看到多个值，这里为每个进程 ID（PID）都有子目录。如果你在 ps 输出中查看一个 PID，就能在/proc 目录中找到它。

现在进入其中一个进程并查看该文件：

```Shell
cat /proc/12345/status
```

你应该能看到进程状态信息以及更详细的信息。/proc 目录是内核查看系统的方式，所以这里的信息比在 ps 中看到的多得多。

## 11. 任务控制

假设你在单个终端窗口中运行一个命令，而这个命令似乎永远不会完成。在它结束之前，你不能与 shell 交互，但我们还想继续使用我们的机器，所以需要保持 shell 打开。幸运的是，我们可以通过任务来控制我们的进程运行：

**将任务发送到后台**

在命令末尾添加一个与号（&），它将在后台运行，这样你仍然可以使用你的 shell。让我们看一个例子：

```Shell
sleep 1000 &
  
sleep 1001 &
  
sleep 1002 &
```
  

**查看所有后台作业**

现在你可以查看刚刚发送到后台的作业。

```Shell
jobs

[1]    Running     sleep 1000 &
  
[2]-   Running     sleep 1001 &
  
[3]+   Running     sleep 1002 &
```

这将显示第一列中的作业 ID，然后是状态和运行的命令。作业 ID 旁边的 **+** 表示它是最近启动的后台作业。带有 **-** 的作业是第二近的命令。

**在现有作业上发送作业到后台**

如果你已经运行了一个任务并想将其发送到后台，你不必终止它并重新开始。首先使用 Ctrl-Z 暂停该任务，然后运行 **bg** 命令将其发送到后台。

  
```Shell
pete@icebox ~ $ sleep 1003
  
^Z
  
[4]+    Stopped     sleep 1003

pete@icebox ~ $ bg
  
[4]+    sleep 1003 &

pete@icebox ~ $ jobs

[1]    Running     sleep 1000 &
  
[2]    Running     sleep 1001 &
  
[3]-   Running     sleep 1002 &
  
[4]+   Running     sleep 1003 &
```
  

**将任务从后台移动到前台**

将任务移出后台只需指定要移出的任务 ID。如果你不带任何选项运行 fg，它将返回最近的后台任务（即旁边带有+号的任务）

```Shell
fg %1
```

**终止后台任务**

与将任务移出后台类似，你可以使用相同的形式通过任务 ID 来终止进程。

```
kill %1
```

