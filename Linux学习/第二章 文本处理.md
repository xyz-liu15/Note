## 1.  stdout

现在，我们已经掌握了许多命令及其输出，这让我们进入了下一个主题——输入/输出（I/O）流。让我们运行以下命令，然后讨论它是如何运作的。

```Shell
echo Hello World > peanuts.txt
```

刚才发生了什么？好吧，检查一下你运行该命令的目录，你就能发现一个名为 peanuts.txt 的文件，打开这个文件，里面应该能看到文本“Hello World”。一条命令里发生了这么多事，我们把它分解分析一下吧。

首先，让我们先来分析第一部分：

```Shell
echo Hello World
```

我们都知道这会在屏幕上打印出 Hello World，但具体原理是什么？进程通过 I/O 流来接收输入和返回输出。默认情况下，***echo*** 命令从键盘获取输入（标准输入(stdin)），并将输出（标准输出(stdout)）显示在屏幕上。所以当你输入 echo Hello World 到 shell 时，屏幕上就会显示 Hello World。不过，I/O 重定向功能让我们可以改变这种默认行为，从而更灵活地处理文件。

让我们进入命令的下一部分：

```Shell
> 
```

> 是一个重定向操作符，允许我们更改标准输出的位置。它让我们能够将 echo Hello World 的输出重定向到文件，而不是显示在屏幕上。如果文件不存在，它会自动创建该文件。但如果文件已存在，它将覆盖原有内容（具体取决于你使用的 shell，可以添加相应的 shell 标志来防止覆盖）。

stdout 重定向的基本工作原理就是这样！

好吧，假设我不想覆盖我的 peanuts.txt 文件，幸运的是，这里有一个重定向运算符，用 ***>>*** :

```Shell
echo Hello World >> peanuts.txt
```

这将会在 peanuts.txt 文件的末尾追加"Hello World"，如果文件不存在，它将会像使用>重定向器那样为我们创建它！

## 2. stdin

在之前的课程中，我们了解到我们可以使用不同的标准输出（stdout）流，比如文件或屏幕。同样，我们也有不同的标准输入（stdin）流可以使用。虽然我们知道键盘等设备提供 stdin，但文件、其他进程的输出和终端也可以作为 stdin 的来源。让我们来看一个例子。

我们在这个例子中使用上一课的 peanuts.txt 文件，记得里面包含"Hello World"文本。

```Shell
cat < peanuts.txt > banana.txt 
```

就像我们之前用 ***>*** 重定向标准输出一样，我们也可以用 ***<*** 重定向标准输入。

通常在 ***cat*** 命令中，你会将一个文件发送给它，该文件就变成了标准输入（stdin）。在这个例子中，我们将 peanuts.txt 重定向为我们的标准输入。然后，cat peanuts.txt 的输出（将会是 Hello World）被重定向到另一个名为 banana.txt 的文件中。

## 3. stderr

现在让我们尝试点别的，比如列出系统上不存在的目录的内容，并将输出再次重定向到 peanuts.txt 文件。

```Shell
ls /fake/directory > peanuts.txt 
```

你应该看到的是：

```Shell
ls: cannot access /fake/directory: No such file or directory
```

现在你可能在想，那条消息不应该是发送到文件里吗？这里实际上还有一个叫做标准错误（stderr）的 I/O 流在起作用。默认情况下，stderr 也会将其输出发送到屏幕上，它和 stdout 是完全不同的流。所以你需要用不同的方式来重定向它的输出。

不幸的是，重定向器不如使用 < 或 > 那么好用，但它已经相当接近了。我们将不得不使用文件描述符。文件描述符是一个非负数，用于访问文件或流。我们稍后会深入讨论这个，但目前要知道，stdin、stdout 和 stderr 的文件描述符分别是 0、1 和 2。

如果我们现在想把标准错误重定向到文件，可以这样做：

```Shell
ls /fake/directory 2> peanuts.txt
```

你应该只看到 peanuts.txt 文件中的 stderr 消息。

现在我想在 peanuts.txt 文件中同时查看标准错误输出和标准输出，这也可以通过文件描述符来实现：

```Shell
ls /fake/directory > peanuts.txt 2>&1
```

这条命令将 ls /fake/directory 的结果发送到 peanuts.txt 文件，并通过 2>&1 将 stderr 重定向到 stdout。这里的操作顺序很重要，因为 2>&1 会将 stderr 发送到 stdout 指向的地方。在这个例子中 stdout 指向一个文件，所以 stderr 也会被写入该文件。因此，如果你打开 peanuts.txt 文件，应该能看到 stderr 和 stdout 的内容。不过，在我们这个例子中，上面的命令只输出了 stderr。

可以将 stdout 和 stderr 同时重定向到文件中，方法更简洁。

```Shell
ls /fake/directory &> peanuts.txt
```

如果我不想留下任何这些杂项，并且想彻底清除 stderr 消息，该怎么办？哦，你还可以将输出重定向到特殊文件/dev/null，它会丢弃所有输入。

```Shell
ls /fake/directory 2> /dev/null
```

## 4. pipe和tee

我们现在来聊聊一些基础操作，虽然不是真的，但有点像。让我们试一个命令：

```Shell
ls -la /etc
```

你应该会看到一个非常长的项目列表，实际上读起来有点困难。与其将这个输出重定向到文件，我们难道不希望能在另一个命令（比如 less）中直接查看输出吗？实际上我们可以这样做！

```Shell
ls -la /etc | less 
```

管道操作符 ***|*** ，用竖线表示，能让我们将一个命令的输出（stdout）作为另一个进程的输入（stdin）。这里我们取了 ls -la /etc 的输出，然后通过管道将其传给 less 命令。管道命令非常实用，我们将一直使用它。

如果我想把命令的输出同时发送到两个不同的流，可以用 tee 命令来实现：

```Shell
ls | tee peanuts.txt
```

你应该能看到 ***ls*** 命令的输出显示在屏幕上，如果打开 peanuts.txt 文件，你也应该能看到同样的信息！

## 5. env

请执行以下命令：

```Shell
echo $HOME
```

你应该能看到你的家目录路径，我的看起来像 /home/pete。

这个命令行怎么样？

```Shell
echo $USER 
```

你应该能看到你的用户名！

这个信息是从哪里获取的？它来源于你的环境变量。你可以通过输入命令来查看这些变量。

```Shell
env 
```

这会输出大量关于当前已设置环境变量的信息。这些变量包含 shell 和其他进程可用的有用信息。

这里有一个简短的示例：

  
```Sehll
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin 
PWD=/home/user 
USER=pete
```

一个特别重要的变量是路径变量。你可以通过在变量名前加上 $ 符号来访问这些变量，例如：

  
```Shell
echo $PATH
  
/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin
  
```

这会返回一个由冒号分隔的路径列表，当你的系统运行命令时会搜索这些路径。假设你手动从互联网下载并安装了一个软件包，并将其放在了一个非标准目录中，然后你想运行那个命令。你输入 $ coolcommand，但系统提示“命令未找到”。这很奇怪，因为你知道二进制文件确实存在于某个文件夹中。实际情况是，$PATH 环境变量没有检查那个目录以找到这个二进制文件，所以系统才会报错。

假设你想运行该目录下的许多可执行文件，只需修改 PATH 变量，将该目录添加到你的 PATH 环境变量中即可。

## 6. cut

我们将学习一些有用的命令，你可以用这些命令来处理文本。在我们开始之前，先创建一个我们将要处理的文件。复制并粘贴以下命令，完成后在 lazy 和 dog 之间按住 Ctrl-v 再按 TAB 键。

```Shell
echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt
```

我们将学习的第一个命令是 cut 命令。这个命令用于从文件中提取文本片段。

通过字符列表提取内容

```Shell
cut -c 5 sample.txt
```

这个命令会输出文件中每行第五个字符。例如，这里输出的是"q"，请注意空格也被视为一个字符。

要通过字段提取内容，我们需要进行一些修改：

```Shell
cut -f 2 sample.txt
```

-f 或 field 标志根据字段切割文本，默认使用 TAB 作为分隔符，因此所有 TAB 分隔的内容都被视为一个字段。你应该看到"dog"作为输出。

你可以将字段标志和分隔符标志结合使用，通过自定义分隔符来提取内容

```Shell
cut -f 1 -d ";" sample.txt
```

这将把 TAB 分隔符改为";"分隔符，由于我们截取了第一个字段，结果应该是"The quick brown"。

## 7. paste

粘贴命令和 cat 命令相似，它将文件中的各行合并。让我们创建一个包含以下内容的新文件：

  
```Shell
sample2.txt
  
The
  
quick
  
brown
  
fox
```
  

让我们把所有这些行合并成一行

```Shell
paste -s sample2.txt
```

默认的粘贴分隔符是制表符，因此现在每行中的单词之间都用制表符分隔。

让我们把分隔符（-d）换成更易读的：

```Shell
paste -d ' ' -s sample2.txt
```

现在所有内容都应该在同一行上，用空格分隔。

## 8. head

假设我们有一个非常长的文件，实际上有很多可以选择，那么就执行 cat /var/log/syslog。你应该看到一页又一页的文本。如果我只想看这个文本文件的前几行怎么办？我们可以用 head 命令来实现，默认情况下，head 命令会显示文件的前 10 行。

```Shell
head /var/log/syslog
```

你也可以自由选择行数，比如我想查看前 15 行。

```Shell
head -n 15 /var/log/syslog
```

-n 标志用于指定行数。

## 9. tail

和 head 命令类似，tail 命令默认会显示文件的最后 10 行。

```Shell
tail /var/log/syslog
```

在 和head 一样的选项中，你可以更改想要查看的行数。

```Shell
tail -n 10 /var/log/syslog
```

另一个很好的选择是你可以使用 -f（跟随）标志，这个标志会持续跟踪文件的增长。试试看会发生什么。

```Shell
tail -f /var/log/syslog
```

当你与系统交互并使用 ***tail -f***  命令时，syslog 文件会持续变化，你可以通过这个命令查看所有添加到该文件中的内容。

## 10. expand和unexpand

在我们讲解 cut 命令的课程中，我们有一个 sample.txt 文件，里面包含制表符。一般情况下，制表符会显示出明显的差异，但有些文本文件中的制表符并不够清晰。文本文件中的制表符可能无法满足你想要的间距。要将制表符转换为空格，可以使用 expand 命令。

```Shell
expand sample.txt
```

上述命令会将每个制表符（TAB）转换成一组空格。若要将此输出保存到文件中，请使用如下输出重定向方法。

```Shell
expand sample.txt > result.txt
```

与扩展相反，我们可以用 unexpand 命令将每一组空格转换回制表符：

```Shell
unexpand -a result.txt
```

## 11. join和split

***join*** 命令可以通过公共字段将多个文件合并在一起：

假设我有两个文件，我想把它们合并起来：  

```Shell
file1.txt
  
1 John
  
2 Jane
  
3 Mary

file2.txt
  
1 Doe
  
2 Doe
  
3 Sue

join file1.txt file2.txt
  
1 John Doe
  
2 Jane Doe
  
3 Mary Sue
```
  

你能看出它是怎么把我的文件合并到一起的吗？默认情况下，文件是按第一个字段合并的，而且这些字段必须一致。如果不一样，你可以先排序，这样在这个例子中，文件就是通过 1、2、3 来合并的。

我们该如何连接这些文件？

```Shell
file1.txt
  
John 1
  
Jane 2
  
Mary 3

file2.txt
  
1 Doe
  
2 Doe
  
3 Sue
```
  

要加入这个文件，你需要指定要加入哪些字段。在这种情况下，我们想要 file1.txt 上的字段 2 和 file2.txt 上的字段 1，因此命令如下：

  
```Shell
join -1 2 -2 1 file1.txt file2.txt
  
1 John Doe
  
2 Jane Doe
  
3 Mary Sue
```
  

"-1 指的是 file1.txt，-2 指的是 file2.txt。这很简洁。你也可以使用 split 命令将一个文件分割成多个不同的文件："

```Shell
split somefile
```

这将会将其分割成不同的文件，默认情况下，当文件达到 1000 行限制时就会进行分割。文件默认命名为 x**。

## 12. sort

排序命令用于对行进行排序。

  
```Shell
file1.txt
  
dog
  
cow
  
cat
  
elephant
  
bird

sort file1.txt
  
bird
  
cat
  
cow
  
dog
  
elephant
```
  

你也可以进行反向排序：

```Shell
sort -r file1.txt
  
elephant
  
dog
  
cow
  
cat
  
bird
```
  

按数值进行排序：

```Shell
sort -n file1.txt
  
bird
  
cat
  
cow
  
elephant
  
dog
```

## 13. tr

tr（翻译）命令允许您将一组字符翻译成另一组字符。让我们尝试一个将所有小写字母转换为大写字母的例子。

```Shell
tr a-z A-Z

hello

HELLO
```

如您所见，我们将a-z的范围转换成了A-Z，并且所有输入的小写文本都被转换成了大写。

## 14. uniq

uniq（唯一）命令是另一个用于解析文本的有用工具。

假设你有一个文件里有很多重复的内容：

  
```Shell
reading.txt
  
book
  
book
  
paper
  
paper
  
article
  
article
  
magazine
```
  

你想要删除重复项，可以使用 uniq 命令：

```Shell
uniq reading.txt
  
book
  
paper
  
article
  
magazine
```

让我们获取一行出现的次数：

```Shell
uniq -c reading.txt
  
2 book
  
2 paper
  
2 article
  
1 magazine
```
让我们只获取唯一值

```Shell
uniq -u reading.txt
  
magazine
```
让我们直接获取重复的值：

```Shell
uniq -d reading.txt
  
book
  
paper
  
article
```
  

Note : uniq 命令不会检测重复行，除非这些行是相邻的。例如：

假设你有一个文件，里面包含不相邻的重复项：

  
```Shell
reading.txt
  
book
  
paper
  
book
  
paper
  
article
  
magazine
  
article
```
  

```Shell
uniq reading.txt
  
reading.txt
  
book
  
paper
  
book
  
paper
  
article
  
magazine
  
article
```

uniq 返回的结果会包含所有条目，而第一个则不会  
示例。

要克服 uniq 的这个限制，我们可以将 sort 和 uniq 结合使用

  
```Shell
sort reading.txt | uniq
  
article
  
book
  
magazine
  
paper
```

## 15. wc和nl

wc (单词计数) 命令用于显示文件中的单词总数。

```Shell
wc /etc/passwd
  
96     265    5925 /etc/passwd
```
  

它分别显示行数、单词数和字节数。

若只想查看某个字段的计数，请分别使用 -l、-w 或 -c 参数。

```Shell
wc -l /etc/passwd
  
96
```

另一个可以用来检查文件行数的命令是 nl（数字行）命令。

  
```Shell
file1.txt
  
i
  
like
  
turtles
```
  

```Shell
nl file1.txt
  
1. i
  
2. like
  
3. turtles
```

## 16. grep

grep 命令可能是你最常用的文本处理命令。它允许你在文件中搜索符合特定模式的字符。如果你想知道某个目录中是否存在某个文件，或者想查看文件中是否包含某个字符串，你当然不会逐行查看文本，而是会使用 grep！

让我们以 sample.txt 文件为例：

```Shell
grep fox sample.txt
```

你应该看到 grep 在 sample.txt 文件里找到了 fox。

你也可以使用 -i 标志进行不区分大小写的模式匹配：

```Shell
grep -i somepattern somefile
```

要让 grep 更灵活，你可以将它与其他命令通过管道符 | 组合使用。

```Shell
env | grep -i User
```

正如你所见，grep 非常强大，你甚至可以在模式中使用正则表达式：

```Shell
ls /somedir | grep '.txt$'
```

应返回 somedir 目录下所有以.txt 结尾的文件。