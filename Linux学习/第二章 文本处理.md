## 1.  stdout

现在，我们已经掌握了许多命令及其输出，这让我们进入了下一个主题——输入/输出（I/O）流。让我们运行以下命令，然后讨论它是如何运作的。

```Shell
echo Hello World > peanuts.txt
```

刚才发生了什么？好吧，检查一下你运行该命令的目录，你就能发现一个名为 peanuts.txt 的文件，打开这个文件，里面应该能看到文本“Hello World”。一条命令里发生了这么多事，我们把它分解分析一下吧。

首先，让我们先来分析第一部分：

```Shell
echo Hello World
```

我们都知道这会在屏幕上打印出 Hello World，但具体原理是什么？进程通过 I/O 流来接收输入和返回输出。默认情况下，***echo*** 命令从键盘获取输入（标准输入(stdin)），并将输出（标准输出(stdout)）显示在屏幕上。所以当你输入 echo Hello World 到 shell 时，屏幕上就会显示 Hello World。不过，I/O 重定向功能让我们可以改变这种默认行为，从而更灵活地处理文件。

让我们进入命令的下一部分：

```Shell
> 
```

> 是一个重定向操作符，允许我们更改标准输出的位置。它让我们能够将 echo Hello World 的输出重定向到文件，而不是显示在屏幕上。如果文件不存在，它会自动创建该文件。但如果文件已存在，它将覆盖原有内容（具体取决于你使用的 shell，可以添加相应的 shell 标志来防止覆盖）。

stdout 重定向的基本工作原理就是这样！

好吧，假设我不想覆盖我的 peanuts.txt 文件，幸运的是，这里有一个重定向运算符，用 ***>>*** :

```Shell
echo Hello World >> peanuts.txt
```

这将会在 peanuts.txt 文件的末尾追加"Hello World"，如果文件不存在，它将会像使用>重定向器那样为我们创建它！

## 2. stdin

在之前的课程中，我们了解到我们可以使用不同的标准输出（stdout）流，比如文件或屏幕。同样，我们也有不同的标准输入（stdin）流可以使用。虽然我们知道键盘等设备提供 stdin，但文件、其他进程的输出和终端也可以作为 stdin 的来源。让我们来看一个例子。

我们在这个例子中使用上一课的 peanuts.txt 文件，记得里面包含"Hello World"文本。

```Shell
cat < peanuts.txt > banana.txt 
```

就像我们之前用 ***>*** 重定向标准输出一样，我们也可以用 ***<*** 重定向标准输入。

通常在 ***cat*** 命令中，你会将一个文件发送给它，该文件就变成了标准输入（stdin）。在这个例子中，我们将 peanuts.txt 重定向为我们的标准输入。然后，cat peanuts.txt 的输出（将会是 Hello World）被重定向到另一个名为 banana.txt 的文件中。

## 3. stderr

现在让我们尝试点别的，比如列出系统上不存在的目录的内容，并将输出再次重定向到 peanuts.txt 文件。

```Shell
ls /fake/directory > peanuts.txt 
```

你应该看到的是：

```Shell
ls: cannot access /fake/directory: No such file or directory
```

现在你可能在想，那条消息不应该是发送到文件里吗？这里实际上还有一个叫做标准错误（stderr）的 I/O 流在起作用。默认情况下，stderr 也会将其输出发送到屏幕上，它和 stdout 是完全不同的流。所以你需要用不同的方式来重定向它的输出。

不幸的是，重定向器不如使用 < 或 > 那么好用，但它已经相当接近了。我们将不得不使用文件描述符。文件描述符是一个非负数，用于访问文件或流。我们稍后会深入讨论这个，但目前要知道，stdin、stdout 和 stderr 的文件描述符分别是 0、1 和 2。

如果我们现在想把标准错误重定向到文件，可以这样做：

```Shell
ls /fake/directory 2> peanuts.txt
```

你应该只看到 peanuts.txt 文件中的 stderr 消息。

现在我想在 peanuts.txt 文件中同时查看标准错误输出和标准输出，这也可以通过文件描述符来实现：

```Shell
ls /fake/directory > peanuts.txt 2>&1
```

这条命令将 ls /fake/directory 的结果发送到 peanuts.txt 文件，并通过 2>&1 将 stderr 重定向到 stdout。这里的操作顺序很重要，因为 2>&1 会将 stderr 发送到 stdout 指向的地方。在这个例子中 stdout 指向一个文件，所以 stderr 也会被写入该文件。因此，如果你打开 peanuts.txt 文件，应该能看到 stderr 和 stdout 的内容。不过，在我们这个例子中，上面的命令只输出了 stderr。

可以将 stdout 和 stderr 同时重定向到文件中，方法更简洁。

```Shell
ls /fake/directory &> peanuts.txt
```

如果我不想留下任何这些杂项，并且想彻底清除 stderr 消息，该怎么办？哦，你还可以将输出重定向到特殊文件/dev/null，它会丢弃所有输入。

```Shell
ls /fake/directory 2> /dev/null
```